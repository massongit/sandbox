
これを学んでいく
http://twitter.github.io/scala_school/advanced-types.html


## View bounds (“type classes”)

時々、参照しかしないで変更を加えることのないオブジェクトをbindすることがあるだろう。
そういう時にimplicitなfunctionで自動的に変換するのが便利っぽい。

    scala> implicit def strToInt(x: String) = x.toInt
    strToInt: (x: String)Int
    
implicitな関数定義。



    scala> "123"
    res0: java.lang.String = 123
    
文字リテラルはjava.lang.Stringと解釈された
    

    scala> val y: Int = "123"
    y: Int = 123
    
変数に型を指定したら、暗黙でtoIntされてるっぽい挙動になる。
これを利用して…

    scala> math.max("123", 111)
    res1: Int = 123
    

引数が文字リテラルであってもtoIntされてmaxを返してくれている。ほほう。


与えられた型でview boundsするには<%を使えば良いと。



コンテナクラスを作ってみよう、と。

    scala> class Container[A <% Int] { def addIt(x: A) = 123 + x }
    defined class Container

できた。
これを使うとこんな感じらしい。



    scala> (new Container[String]).addIt("123")
    res11: Int = 246
    
    scala> (new Container[Int]).addIt(123) 
    res12: Int = 246

    scala> (new Container[Float]).addIt(123.2F)
    <console>:8: error: could not find implicit value for evidence parameter of type (Float) => Int
       (new Container[Float]).addIt(123.2)
        ^

ふーん、Floatはダメになるのか。


## Other type bounds

その他のbounds？かな。
なんちゅーか、もっと複雑な型のboundsもimplicitパラメーターで可能、と。
例えば、Scalaでは数値を扱うクラスの継承関係が綺麗なピラミッドではないらしく、親クラスでまとめあげるみたいなことは出来ないと。


[defines an implicit Numeric[T] for the appropriate types T](http://www.azavea.com/blogs/labs/2011/06/scalas-numeric-type-class-pt-1/)

こうしろ、と。

    sum[B >: A](implicit num: Numeric[B]): B


