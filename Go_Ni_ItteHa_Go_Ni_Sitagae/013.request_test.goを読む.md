

何故か[別リポジトリのissue](https://github.com/yyYank/my-first-go/issues/7)との連動企画。

コードリーディングをしていく。


## TestQuery

```go
func TestQuery(t *testing.T) {
	req := &Request{Method: "GET"}
	req.URL, _ = url.Parse("http://www.google.com/search?q=foo&q=bar")
	if q := req.FormValue("q"); q != "foo" {
		t.Errorf(`req.FormValue("q") = %q, want "foo"`, q)
	}
}
```

testing.Tのポインタが引数になっているTestQuery関数。
最初にRequestを作っている。メンバのMethodに"GET"を指定しているぽい。
突然出てくるurlはimportしているnet/urlのパッケージ？と捉えると良いのかな。
url.goのParse関数でURL文字列をparse。requestのURLメンバ変数に代入してるっぽい。
_はたしか使わないって意味だったと思う。
requestからゲットパラメータを取得。fooが取れなかったらおかしいのでエラーログを出す。



## TestParseFormQuery

```go

func TestParseFormQuery(t *testing.T) {
	req, _ := NewRequest("POST", "http://www.google.com/search?q=foo&q=bar&both=x&prio=1&orphan=nope&empty=not",
		strings.NewReader("z=post&both=y&prio=2&=nokey&orphan;empty=&"))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	if q := req.FormValue("q"); q != "foo" {
		t.Errorf(`req.FormValue("q") = %q, want "foo"`, q)
	}
	if z := req.FormValue("z"); z != "post" {
		t.Errorf(`req.FormValue("z") = %q, want "post"`, z)
	}
	if bq, found := req.PostForm["q"]; found {
		t.Errorf(`req.PostForm["q"] = %q, want no entry in map`, bq)
	}
	if bz := req.PostFormValue("z"); bz != "post" {
		t.Errorf(`req.PostFormValue("z") = %q, want "post"`, bz)
	}
	if qs := req.Form["q"]; !reflect.DeepEqual(qs, []string{"foo", "bar"}) {
		t.Errorf(`req.Form["q"] = %q, want ["foo", "bar"]`, qs)
	}
	if both := req.Form["both"]; !reflect.DeepEqual(both, []string{"y", "x"}) {
		t.Errorf(`req.Form["both"] = %q, want ["y", "x"]`, both)
	}
	if prio := req.FormValue("prio"); prio != "2" {
		t.Errorf(`req.FormValue("prio") = %q, want "2" (from body)`, prio)
	}
	if orphan := req.Form["orphan"]; !reflect.DeepEqual(orphan, []string{"", "nope"}) {
		t.Errorf(`req.FormValue("orphan") = %q, want "" (from body)`, orphan)
	}
	if empty := req.Form["empty"]; !reflect.DeepEqual(empty, []string{"", "not"}) {
		t.Errorf(`req.FormValue("empty") = %q, want "" (from body)`, empty)
	}
	if nokey := req.Form[""]; !reflect.DeepEqual(nokey, []string{"nokey"}) {
		t.Errorf(`req.FormValue("nokey") = %q, want "nokey" (from body)`, nokey)
	}
}

```
これ結構長いな。めんど。。
NewRequestはrequest.goの持つ関数。
NewRequestは関数
strings.NewReaderはstringsというユーティリティーパッケージ？の関数。Readerインターフェースを返すっぽい。

* NOTE:パッケージというかディレクトリを指すっぽい

```
// NewReader returns a new Reader reading from s.
// It is similar to bytes.NewBufferString but more efficient and read-only.
```

とのこと。
その後、req変数に対してリクエストヘッダを設定している。

```go
if bq, found := req.PostForm["q"]; found {
```

って書いてあるけど、戻り値のfoundをifの論理演算にそのまま使えるということか。
・・・軽くググったけど、そうみたいね。前にもコレを調べた記憶ある。

PostFormばメンバ変数。実体はurl.Valuesでtype Values map[string][]stringなので連想配列と言ったところか。
したがってkey = qのものでvalueを取ろうとしていることになる。

PostFormValueは関数。ややこしいな。命名規則でメンバ変数か関数が見分けつかんじゃないの。
POSTやPUTのリクエストボディではじめに見つけたものを返す関数らしい。
URLのquery parametersは無視される。
次がreflectパッケージのDeepEqual、、、名前でだいたい想像つく。
Formの中身が等しいかということだろうな。
あとは大体それのバリエーションを試している感じかな。
